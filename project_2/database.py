import pymongo
from pymongo import MongoClient
import csv
import configparser

"""
Connection Information
"""
config = configparser.ConfigParser()
config.read('config.ini')
connection_string = config['database']['mongo_connection']

#######################
# Initialization Info #
#######################
customers = None
products = None
orders = None

customers_keys = ('id', 'firstName', 'lastName',
                  'street', 'city', 'state', 'zip')
products_keys = ('id', 'name', 'price')
orders_keys = ('orderId', 'customerId', 'productId', 'date')

#######
# Because ids are uniquely generated by mongodb
# were going to have to get those ourselves
# to fill order data
#######


"""
Utilities
"""


def to_list(keys, document):
    record = []
    for key in keys:
        record.append(document[key])
    return record


def join(keys, document, record):
    for key in keys:
        record.append(document[key])
    return record


def load_data():
    customers = list()
    with open('customers.csv', newline='') as csvfile:
        spamreader = csv.reader(csvfile)
        for row in spamreader:
            customers.append(row)

    products = list()
    with open('products.csv', newline='') as csvfile:
        spamreader = csv.reader(csvfile)
        for row in spamreader:
            products.append(row)
    return [customers, products]

######################
# End Initialization #
######################

def initialize():

    existing = customers.find({})

    if existing.count() < 1:
        data = load_data()
        for d in data[0]:
            upsert_customer(d)
        for d in data[1]:
            upsert_order(d)

def get_customers():
    for item in customers.find({}):
        yield to_list(customers_keys, item)


def get_customer(id):
    query = {}

    if id:
        query = {"id" : ObjectId(id)}
    
        # TODO: return the customer in the document
        for c in customers.find(query):
            return None
    
    else:
        # if we dont want a single customer,
        # we want them all
        get_customers()


def upsert_customer(customer):
    """
    TODO: Needs to handle two cases: if the customer does not exist in the
    database and if the customer already exists in the database
    """
    customers.insert_one({'id' : ObjectId(),'firstName' : customer[0], 'lastName' : customer[1], \
                        'street' : customer[2], 'city' : customer[3], \
                        'state' : customer[4], 'zip' : customer[5]})


def delete_customer(id):
    customers.delete_one({'id' : ObjectId(id)})


def get_products():
    for item in products.find({}):
        yield to_list(products_keys, item)


def get_product(id):
    query = {}

    if id:
        query = {'id' : ObjectId(id)}
    
        for p in products.find(query):
            yield to_list(products_keys, p)
    
    else:
        get_products()


def upsert_product(product):
    """
    TODO: Needs to handle if a product already exists in the database
    """
    products.insert_one({'id' : ObjectId(), 'name' : product[0], 'price' : product[1]})


def delete_product(id):
    products.delete_one({'id' : ObjectId(id)})


def get_orders():
    for item in orders.find({}):
        yield to_list(orders_keys, item)


def get_order(id):
    query = {}

    if id:
        query = {'id' : ObjectId(id)}

        """
        TODO: Needs to also return the customer information,
        likely want to join any related customer info or maybe even
        just put that information in the document. Thats the beauty of
        document stores.
        """
        for o in orders.find(query):
            yield to_list(orders_keys, o)
    else:
        get_orders()


def upsert_order(order):
    orders.insert_one({'id' : ObjectId() ,'customerId' : order[0], 'productId' : order[1], 'date' : order[2]})


def delete_order(id):
    orders.delete_one({'id' : ObjectId(id)})


def customer_report(id):
    return None


# Pay close attention to what is being returned here.  Each product in the products
# list is a dictionary, that has all product attributes + last_order_date, total_sales, and
# gross_revenue.  This is the function that needs to be use Redis as a cache.

# - When a product dictionary is computed, save it as a hash in Redis with the product's
#   ID as the key.  When preparing a product dictionary, before doing the computation,
#   check if its already in redis!
def sales_report():
    return list()

############################
# Connects to the database #
############################


def connect_to_db(conn_str):
    global customers
    global products
    global orders
    client = MongoClient(conn_str)
    customers = client.project2.customers
    products = client.project2.products
    orders = client.project2.orders
    return client


conn = connect_to_db(connection_string)
initialize()
